#!/usr/bin/env bash

#  http://github.com/thewoolleyman/boxbuilder
#  Copyright (c) 2010 Chad Woolley - The MIT License

boxbuilder_debug=${boxbuilder_debug:-false}

if [[ $boxbuilder_debug = true ]]; then
  export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
  set -o verbose
  set -o xtrace
fi

set -o errexit
set -o errtrace
set -o noclobber
set -o nounset
set -o pipefail

_log_prefix="BOXBUILDER - $BASH_SOURCE:"

function onexit() {
  local exit_status=${1:-$?}
  if [[ $exit_status != 0 ]]; then
    _error_line="error trapped."
  else
    _error_line=''
  fi
  if [[ $(type -t onexit_hook) = 'function' ]]; then
    onexit_hook
  fi
  echo "$_log_prefix $_error_line Exiting $0 with $exit_status"
  exit $exit_status
}

function disable_error_checking() {
  trap - ERR
  set +o errexit
}

function enable_error_checking() {
  trap onexit ERR
  set -o errexit
}

trap onexit HUP INT QUIT TERM ERR

detect_platform() {
  _uname=$(uname -a)
  if echo "$_uname" | grep -i 'debian'; then
    _platform='debian'
  elif echo "$_uname" | grep -i 'ubuntu'; then
    _platform='debian'
  elif [[ -f /etc/redhat-release ]]; then
    _platform='redhat'
  elif echo "$_uname" | grep -i 'darwin'; then
    # TODO: for now, darwin platform assumes you are using HomeBrew
    _platform='darwin'
  else
    echo "$_log_prefix error on line $LINENO - unable to determine supported platform from uname: '$_uname'"
    return 1
  fi
  echo "$_log_prefix  Platform detected as '$_platform'"
}

setup_image_vars_redhat() {
  _release="5.4"
  _standard_ami_prefix="redhat-$_release-$_arch"
  _standard_ami_description="redhat $_release $_arch"
  _imagesource="http://mirrors.usc.edu/pub/linux/distributions/centos/$_release/os/$_arch/images/stage2.img"
  _image="/mnt/stage2.img"
  _image_fs_type="squashfs"
  _imagedir="/mnt/stage2"
}

setup_image_vars_debian() {
  _codename="lucid"
  _release="10.04"
  _tag="server"

  _standard_ami_prefix="ubuntu-$_release-$_codename-$_tag-$_arch"
  _standard_ami_description="Ubuntu $_release $_codename $_tag $_arch"
  _imagesource="http://uec-images.ubuntu.com/releases/$_codename/release/unpacked/ubuntu-$_release-$_tag-uec-$_arch2.img.tar.gz"
  _image="/mnt/$_codename-$_tag-uec-$_arch2.img"
  _image_fs_type="ext3"
  _imagedir="/mnt/$_codename-uec-$_arch2"
}

setup_image_vars() {
  echo "$_log_prefix  Image variable setup for platform $_platform..."

  # TODO: Make sure these kernel and ramdisk values are correct for all platforms
  if [[ $(uname -m) = "x86_64" ]] ; then
    _arch=x86_64
    _arch2=amd64
    _ebsopts="--kernel=aki-0b4aa462 --ramdisk=ari-c515f6ac --block-device-mapping /dev/sdb=ephemeral0"
  else
    _arch=i386
    _arch2=i386
    _ebsopts="--kernel=aki-754aa41c --ramdisk=ari-0915f660  --block-device-mapping /dev/sda2=ephemeral0"
  fi

  setup_image_vars_$_platform

  echo "$_log_prefix  Finished image variable setup for platform $_platform:"
  echo "_standard_ami_prefix=$_standard_ami_prefix"
  echo "_standard_ami_description=$_standard_ami_description"
  echo "_imagesource=$_imagesource"
  echo "_image=$_image"
  echo "_imagedir=$_imagedir"
}

setup() {
  echo "$_log_prefix  Environment variable setup ..."
  if [ -e $HOME/.boxbuilder_build_amirc ]; then
    source $HOME/.boxbuilder_build_amirc
  fi
  
  boxbuilder_config=${boxbuilder_config:-'export boxbuilder_config_placeholder_from_boxbuilder_build_ami=boxbuilder_config_placeholder_from_boxbuilder_build_ami'}
  eval $boxbuilder_config
  boxbuilder_branch=${boxbuilder_branch:-"master"}
  boxbuilder_bootstrap_url=${boxbuilder_bootstrap_url:-"http://github.com/thewoolleyman/boxbuilder/raw/$boxbuilder_branch/boxbuilder_bootstrap"}
  boxbuilder_user=${boxbuilder_user:-"$USER"}
  boxbuilder_ami_prefix=${boxbuilder_ami_prefix:-"built-by-boxbuilder"}
  boxbuilder_ec2_api_tools_url=${boxbuilder_ec2_api_tools_url:-"http://s3.amazonaws.com/ec2-downloads/ec2-api-tools.zip"}

  EC2_CERT=${EC2_CERT:-""}
  EC2_PRIVATE_KEY=${EC2_PRIVATE_KEY:-""}
  
  setup_image_vars

  echo "$_log_prefix  Finished environment variable setup:"
  echo "boxbuilder_config=$boxbuilder_config"
  # TODO: Add all env vars which are directly used by this script
}

set_ec2_credentials() {
  echo "$_log_prefix Setting EC2 credentials ..."
  
  if [[ -z $EC2_CERT ]]; then
    EC2_CERT=( $HOME/.ec2/cert-*.pem ) # grab first file using bash array
    echo "$_log_prefix EC2_CERT is not set, loading from $HOME/.ec2/cert-*.pem ..."
  fi

  if [[ ! -e $EC2_CERT ]]; then
    echo "$_log_prefix ERROR: EC2_CERT was not found at $EC2_CERT, exiting ..."
    return 1
  fi

  if [[ -z $EC2_PRIVATE_KEY ]]; then
    EC2_PRIVATE_KEY=( $HOME/.ec2/pk-*.pem ) # grab first file using bash array
    echo "$_log_prefix EC2_PRIVATE_KEY is not set, loading from $HOME/.ec2/pk-*.pem ..."
  fi

  if [[ ! -e $EC2_PRIVATE_KEY ]]; then
    echo "$_log_prefix ERROR: EC2_PRIVATE_KEY was not found at $EC2_PRIVATE_KEY, exiting ..."
    return 1
  fi

  export EC2_CERT
  export EC2_PRIVATE_KEY

  echo "$_log_prefix Finished setting EC2 credentials.  Using EC2_CERT=$EC2_CERT and EC2_PRIVATE_KEY=$EC2_PRIVATE_KEY ..."
}

#install_ec2_tools() {
#  echo "$_log_prefix Installing ec2 tools ..."
#  echo "$_log_prefix Ensuring that multiverse is added to /etc/apt/sources.list so ec2 packages can be installed ..."
#  sudo sed -i".bak-$(date +%Y%m%d-%H%M)" -e 's/universe$/universe multiverse/' /etc/apt/sources.list
#  echo "$_log_prefix Updating apt and installing EC2 tools ..."
#  sudo apt-get update
#  sudo -E apt-get install -y ec2-api-tools ec2-ami-tools
#  echo "$_log_prefix Finished installing ec2 tools ..."
#}

install_packages_redhat() {
  sudo yum install -y unzip java shadow-utils
  export JAVA_HOME="/usr/lib/jvm/jre"
}

install_packages_debian() {
  sudo -E apt-get install -y unzip default-jre-headless
  export JAVA_HOME="/usr/lib/jvm/default-java"
}

install_packages() {
  install_packages_$_platform
}

set_up_ec2_tools() {
  echo "$_log_prefix Setting up EC2 tools ..."

  _ec2_tools_path=$HOME/.boxbuilder_ec2_tools
  _ec2_api_tools_path=$_ec2_tools_path/ec2-api-tools
  if [[ -x $_ec2_api_tools_path/bin/ec2-run-instances ]]; then
    echo "$_log_prefix EC2 API Tools already exist at $_ec2_api_tools_path.  Not re-downloading ..."
  else
    mkdir -p $_ec2_tools_path
    if [[ ! $(which unzip) ]]; then
      echo "$_log_prefix ERROR: 'unzip' executable not available.  It is required to unzip auto-downloaded EC2 API Tools. Either put unzip with on your path, or manually unzip the EC2 API Tools to $_ec2_api_tools_path ..."
      return 1
    fi
    _ec2_api_tools_zipfile=$_ec2_tools_path/${boxbuilder_ec2_api_tools_url##*/} # grabs last path component of url to use as zipfile name
    echo "$_log_prefix EC2 API Tools do not exist at $_ec2_api_tools_path.  Downloading from $boxbuilder_ec2_api_tools_url to $_ec2_api_tools_path ..."
    wget -O $_ec2_api_tools_zipfile $boxbuilder_ec2_api_tools_url
    echo "$_log_prefix Reading top-level directory for $_ec2_api_tools_zipfile ..."
    # Zipfile is structured with top-level directory containing the release date, so we must determine what it is, extract, and symlink it to _ec2_api_tools_path
    disable_error_checking
    _first_zipfile_listing_entry=$(unzip -l $_ec2_api_tools_zipfile | head -n4 | tail -n1) # _first_zipfile_listing_entry should be top-level zipfile dir
    enable_error_checking
    _top_level_zipfile_dir=${_first_zipfile_listing_entry##* } # grab just last space-delimited directory component from _first_zipfile_listing_entry
    _top_level_zipfile_dir=${_top_level_zipfile_dir%%/} # strip trailing slash
    echo "$_log_prefix Unzipping $_ec2_api_tools_zipfile to $_ec2_tools_path ..."
    unzip -o -d $_ec2_tools_path $_ec2_api_tools_zipfile # Unzip to $HOME/.boxbuilder_ec2_tools
    echo "$_log_prefix Symlinking $_ec2_tools_path/$_top_level_zipfile_dir to $_ec2_api_tools_path ..."
    ln -sf $_ec2_tools_path/$_top_level_zipfile_dir $_ec2_api_tools_path # symlink to simple directory name without release date.
  fi
  export EC2_HOME=$_ec2_api_tools_path
  export PATH=$EC2_HOME/bin:$PATH
  echo "$_log_prefix Finished setting up EC2 tools ..."
}

create_chroot_jail_from_base_image() {
  echo "$_log_prefix Creating chroot jail from base image $_imagesource ..."
  if [[ -e $_image ]]; then
    echo "$_log_prefix Image $_image already exists.  Not downloading again ..."
  else
    if [[ "$_imagesource" = *.img ]]; then
      echo "$_log_prefix Downloading image from $_imagesource ..."
      sudo wget --progress=dot:mega -O $_image $_imagesource
    else
      echo "$_log_prefix Downloading image from $_imagesource and unzipping to $_image ..."
      wget --progress=dot:mega -O- $_imagesource | sudo tar xzf - -C /mnt
    fi
  fi

  if which uec-resize-image; then
    # Only available on Ubuntu, but only needed on Ubuntu
    echo "$_log_prefix Resizing $_image to 5G ..."
    # Resize image so we have enough space to install in chroot
    # Not sure if one or both of uec-resize-image and resize2fs are needed
    sudo uec-resize-image $_image 5G
  fi

  echo "$_log_prefix Ensuring existing loop device at /dev/loop4 is unmounted ..."
  # Ensure existing loop device is unmounted (allows script to be run multiple times)
  _mount_output=$(mount)
  if echo $_mount_output | grep '/dev/loop4'; then
    sudo umount -dfl /dev/loop4
  fi 

  echo "$_log_prefix Mounting loop device at /dev/loop4 ..."
  if [[ $_image_fs_type = 'squashfs' ]]; then
    sudo mkdir -p $_imagedir-readonly
    sudo mount -o loop=/dev/loop4 -t $_image_fs_type $_image $_imagedir-readonly
    sudo cp -r $_imagedir-readonly $_imagedir
  else
    sudo mkdir -p $_imagedir
    sudo mount -o loop=/dev/loop4 -t $_image_fs_type $_image $_imagedir
  fi

  if which resize2fs; then
    echo "$_log_prefix Resizing loop device at /dev/loop4 to 5G ..."
    # Sometimes this is needed even though image was resized before mount with uec-resize-image?
    sudo resize2fs /dev/loop4 5G
  fi

  sudo /usr/sbin/chroot $_imagedir mount -t proc none /proc
  sudo mkdir -p $_imagedir/dev/pts
  sudo /usr/sbin/chroot $_imagedir mount -t devpts none /dev/pts

  echo "$_log_prefix Finished creating chroot jail from base image $_imagesource ..."
}

ensure_boxbuilder_user_exists() {
  echo "$_log_prefix  Ensuring boxbuilder_user '$boxbuilder_user' exists in chroot jail ..."
  if [[ $boxbuilder_user = 'root' ]]; then
    echo "$_log_prefix  boxbuilder_user cannot be root.  Please set \
boxbuilder_user to a non-root user.  If it does not exist, it will be \
automatically created..."
    return 1
  fi
  if sudo grep -e "^$boxbuilder_user:" $_imagedir/etc/shadow; then
    echo "$_log_prefix  boxbuilder_user '$boxbuilder_user' already exists in chroot jail ..."
    return 0
  fi
  echo "$_log_prefix  boxbuilder_user '$boxbuilder_user' does not exist, automatically creating it ..."

  if [[ $_platform = 'redhat' ]]; then
    echo "$_log_prefix  Installing yum in chroot jail..."
    # NOTE: Install of yum in chroot via --installroot brings a lot of packages with it,
    #       using builder instances yum config (presumably).  Is this bad?
    sudo yum -y --installroot="$_imagedir" install yum
    echo "$_log_prefix  Installing shadow-utils package in chroot jail to provide groupadd utility..."
    sudo /usr/sbin/chroot $_imagedir /usr/bin/yum install -y shadow-utils
  fi

  echo "$_log_prefix  Ensuring 'admin' group exists ..."
  sudo /usr/sbin/chroot $_imagedir groupadd -f admin
  _admin_gid=$(sudo /usr/sbin/chroot $_imagedir "grep 'admin' /etc/group | cut -d: -f3")
  echo "$_log_prefix  Automatically creating '$boxbuilder_user' user ..."
  sudo /usr/sbin/chroot $_imagedir useradd $boxbuilder_user -m -g $_admin_gid
  echo "$_log_prefix  Finding home dir for '$boxbuilder_user' user ..."
  _boxbuilder_user_home=$(sudo /usr/sbin/chroot $_imagedir su - $boxbuilder_user -c "echo $HOME")
  if sudo /usr/sbin/chroot $_imagedir su - $boxbuilder_user; then
    echo "$_log_prefix  boxbuilder_user '$boxbuilder_user' successfully created in chroot jail..."
  else
    echo "$_log_prefix  boxbuilder_user '$boxbuilder_user' was NOT successfully created in chroot jail - something went wrong :( - try setting boxbuilder_debug=true ..."
    return 1
  fi
}

grant_nopasswd_sudo_access_in_chroot() {
  echo "$_log_prefix  Checking no-password and no requiretty sudo access for 'admin' group on host $boxbuilder_host and adding if necessary.  If prompted, please type your password, or ctrl-c to abort..."

  _needs_nopasswd_sudoers_added=false
  if ! sudo grep -e "%admin.*ALL.*=.*NOPASSWD.*:.*ALL" $_imagedir/etc/sudoers; then
    _needs_nopasswd_sudo=true
  fi

  _needs_requiretty_sudoers_removed=false
  if sudo grep 'requiretty' $_imagedir/etc/sudoers; then
    _needs_requiretty_sudoers_removed=true
  fi

  if ! $_needs_nopasswd_sudoers_added && ! $_needs_requiretty_sudoers_removed; then
    echo "$_log_prefix  no sudoers changes needed ..."
    return 0
  fi

  sudo /usr/sbin/chroot $_imagedir cp /etc/sudoers /etc/sudoers.bak

  if $_needs_requiretty_sudoers_removed; then
    sudo /usr/sbin/chroot $_imagedir "cat /etc/sudoers | grep -v 'requiretty' > /tmp/sudoers.new"
  else
    sudo /usr/sbin/chroot $_imagedir "cp /etc/sudoers /tmp/sudoers.new"
  fi

  if $_needs_nopasswd_sudoers_added; then
    echo "$_log_prefix  Giving user $boxbuilder_user NO PASSWORD sudo privileges"
    new_sudoers_line="%admin ALL=NOPASSWD: ALL"
    sudo /usr/sbin/chroot $_imagedir sh -c "echo '$new_sudoers_line' >> /tmp/sudoers.new"
  fi

  if [[ ! -e $_imagedir/tmp/sudoers.new ]]; then
    echo "$_log_prefix error on line $LINENO - Could not add create /tmp/sudoers.new on host $boxbuilder_host.  Please manually add this entry using visudo: $new_sudoers_line"
    return 1
  fi

  if ! sudo /usr/sbin/chroot $_imagedir visudo -c -s -f /tmp/sudoers.new; then
    echo "$_log_prefix error on line $LINENO -: Syntax error in /tmp/sudoers.new on host $boxbuilder_host.  Please manually add this entry using visudo: $new_sudoers_line"
    return 1
  fi
  sudo /usr/sbin/chroot $_imagedir cp /tmp/sudoers.new /etc/sudoers
}

perform_initial_chroot_jail_setup() {
  echo "$_log_prefix Performing initial setup on chroot jail at $_imagedir ..."
  # Allow network access from chroot environment
  sudo cp /etc/resolv.conf $_imagedir/etc/
  # Remove hostname
  sudo rm -f $_imagedir/etc/hostname
  if [[ $_platform = 'debian' ]]; then
    sudo /usr/sbin/chroot $_imagedir apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BE09C571
  fi
  sudo /usr/sbin/chroot $_imagedir su - $boxbuilder_user -c "touch /home/$boxbuilder_user/.bash_history"
}

run_boxbuilder_bootstrap_in_chroot_jail_to_build_image() {
  echo "$_log_prefix Running boxbuilder_bootstrap in chroot jail to build image ..."
  echo "$_log_prefix Performing custom setup in $_imagedir using script at $boxbuilder_bootstrap_url ..."
  _boxbuilder_bootstrap_script=/tmp/${boxbuilder_bootstrap_url##*/} # grabs last path component of url to use as script name
  echo "$_log_prefix Downloading $_boxbuilder_bootstrap_script from $boxbuilder_bootstrap_url ..."
  sudo /usr/sbin/chroot $_imagedir wget -O $_boxbuilder_bootstrap_script $boxbuilder_bootstrap_url
  echo "$_log_prefix $boxbuilder_bootstrap_url successfully downloaded to $_boxbuilder_bootstrap_script ..."

  echo "$_log_prefix Changing permissions on $_boxbuilder_bootstrap_script ..."
  sudo /usr/sbin/chroot $_imagedir chmod a+x $_boxbuilder_bootstrap_script
  echo "$_log_prefix Running $_boxbuilder_bootstrap_script ..."
  # TODO: does this pass everything in environment and $boxbuilder_config, or do we need to do more?
  sudo /usr/sbin/chroot $_imagedir sudo -u $boxbuilder_user -i bash -c "export boxbuilder_config='$boxbuilder_config' \
    && export boxbuilder_debug=$boxbuilder_debug \
    && $_boxbuilder_bootstrap_script"
  echo "$_log_prefix Finished running boxbuilder_bootstrap in chroot jail to build image ..."
}

copy_image_to_ami() {
  echo "$_log_prefix Copying image to AMI ..."
  echo "$_log_prefix Cleaning up mounts and policy-rc.d in chroot jail before copying image ..."
  _mount_output=$(sudo /usr/sbin/chroot $_imagedir mount)
  if echo $_mount_output | grep '/proc'; then
    sudo /usr/sbin/chroot $_imagedir umount /proc
  fi
  if echo $_mount_output | grep '/dev/pts'; then
    sudo /usr/sbin/chroot $_imagedir umount /dev/pts
  fi
  sudo rm -f $_imagedir/usr/sbin/policy-rc.d
  
  _size=15 # root disk in GB
  _now=$(date +%Y%m%d-%H%M)
  _full_ami_prefix="$boxbuilder_ami_prefix-$_standard_ami_prefix-$_now"
  _full_ami_description="$_standard_ami_description $_now"

  echo "$_log_prefix Ensuring no existing volume is already attached at /dev/sdi ..."
  # TODO: why do we need set +o errexit?
  disable_error_checking
  _existing_volumeid=$(ec2-describe-volumes --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT | grep -e '^ATTACHMENT.*/dev/sdi' | cut -f2)
  enable_error_checking
  if [[ ! -z $_existing_volumeid ]]; then
    echo "$_log_prefix Volume $_existing_volumeid is already attached at /dev/sdi.  Detaching and deleting ..."
    ec2-detach-volume --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT -f $_existing_volumeid
    ec2-delete-volume --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT $_existing_volumeid
  fi
  echo "$_log_prefix Ensuring nothing is mounted at /dev/sdi ..."
  _mount_output=$(mount)
  if echo $_mount_output | grep '/dev/sdi'; then
    echo "$_log_prefix /dev/sdi is already mounted.  Unmounting ..."
    sudo umount /dev/sdi
  fi
  
  echo "$_log_prefix Creating new volume ..."
  _volumeid=$(ec2-create-volume --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT \
    --size $_size \
    --availability-zone us-east-1a \
    | cut -f2)
  
  echo "$_log_prefix Retrieving current instance id ..."
  _instance_id=$(wget --progress=dot -qO- http://instance-data/latest/meta-data/instance-id)
  
  echo "$_log_prefix Attaching new volume $_volumeid to current instance $_instance_id at device /dev/sdi ..."
  ec2-attach-volume --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT --device /dev/sdi --instance "$_instance_id" "$_volumeid"
  while [ ! -e /dev/sdi ]; do echo -n .; sleep 1; done
  
  echo "$_log_prefix Creating filesystem on /dev/sdi ..."
  sudo mkfs.ext3 -F /dev/sdi
  _imagedir_ebs=$_imagedir-ebs
  
  echo "$_log_prefix Mounting device /dev/sdi mounted at $_imagedir_ebs ..."
  sudo rm -rf $_imagedir_ebs
  sudo mkdir -p $_imagedir_ebs
  sudo mount -t ext3 /dev/sdi $_imagedir_ebs
  echo "$_log_prefix Copying built image from chroot jail at $_imagedir to EBS volume $_volumeid attached to device /dev/sdi mounted at $_imagedir_ebs ..."
  sudo tar -cSf - -C $_imagedir . | sudo tar xf - -C $_imagedir_ebs

  echo "$_log_prefix Unmounting $_imagedir_ebs ..."
  sudo umount $_imagedir_ebs
  echo "$_log_prefix Detaching EC2 volume $_volumeid ..."
  ec2-detach-volume --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT "$_volumeid"
  
  echo "$_log_prefix Creating snapshot of volume $_volumeid ..."
  _snapshotid=$(ec2-create-snapshot --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT "$_volumeid" \
    -d 'boxbuilder_temp_resource_safe_to_terminate (if not in use by an AMI)' \
    | cut -f2)
  ec2-delete-volume --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT "$_volumeid"
  while ec2-describe-snapshots --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT "$_snapshotid" | grep -q pending
    do echo -n .; sleep 5; done
  _ec2_register_output=$(ec2-register --private-key $EC2_PRIVATE_KEY --cert $EC2_CERT \
    --architecture $_arch \
    --name "$_full_ami_prefix" \
    --description "$_full_ami_description" \
    $_ebsopts \
    --snapshot "$_snapshotid")
  _newami=$(echo $_ec2_register_output | cut -f2)
  _newami=${_newami##IMAGE?} # strip the 'IMAGE ' prefix ('?' glob matches a space or tab as delimiter)

  echo "$_log_prefix NEW AMI SUCCESSFULLY CREATED AND REGISTERED:"
  echo "$_log_prefix grep and following output lines and evaluate them to retrieve and set local variables describing the new AMI"
  echo "------------------------------------"
  echo "boxbuilder_created_ami_id='$_newami'"
  echo "boxbuilder_created_ami_ebs_id='$_volumeid'"
  echo "boxbuilder_created_ami_ebs_snapshot_id='$_snapshotid'"
  echo "boxbuilder_created_ami_prefix='$_full_ami_prefix'"
  echo "boxbuilder_created_ami_description='$_full_ami_description'"
  echo "------------------------------------"
  echo "$_log_prefix Finished copying image to AMI ..."
}

run() {
  echo "$_log_prefix Starting ..."
  detect_platform
  setup_image_vars
  setup
  set_ec2_credentials
  install_packages
  set_up_ec2_tools
  create_chroot_jail_from_base_image
  ensure_boxbuilder_user_exists
  grant_nopasswd_sudo_access_in_chroot
  perform_initial_chroot_jail_setup
  run_boxbuilder_bootstrap_in_chroot_jail_to_build_image
  copy_image_to_ami
  echo "$_log_prefix Finished and exiting successfully"
}

run
onexit
